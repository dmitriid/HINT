{"tagline":"Erlang type search engine.","body":"# TOC\r\n\r\n1. What is it?  \r\n    DEMO\r\n2. Technical details\r\n3. How to?  \r\n    3.1 Generate your own PLT  \r\n    3.2 Use your own PLT  \r\n    3.3 See some results on the command line  \r\n4. Weak points and future solutions\r\n\r\n# 1. WHAT IS IT?\r\n\r\nHave you ever tried Hoogle? http://www.haskell.org/hoogle/\r\n \r\nIf you haven't, here's a brief description. \r\n\r\nQuite often you don't know the name of a function, or the name of the module it resides in, but you know what types you'd like this function to accept and what types this function will output.\r\n\r\nHoogle let's you search based on type signatures of functions. One small problem though... It's Haskell only, no Erlang.\r\n\r\nWouldn't it be nice to type in something like\r\n\r\n       proplists:?(any(), list()) -> any()\r\n\r\nand get back\r\n\r\n       proplists:get_value\r\n\r\nOr type in \r\n\r\n       \"(erlang:timestamp(),erlang:timestamp())->integer()\"\r\n\r\nand get back\r\n\r\n       erlang:now_diff\r\n\r\n?\r\n\r\nThat's the goal of HINT: to provide you with a way to search for function definitions and documentation by function type signatures.\r\n\r\n# DEMO\r\n\r\n1. Start web.sh\r\n2. Go to http://127.0.0.1/52012\r\n\r\nGive some time for web.sh to start completely. If it doesn't work, clean && compile && run.\r\n\r\n3. Demo URLs (on Monday):  \r\n- http://memorici.de:52012\r\n- http://booktu.com\r\n- http://dmitriid.com:52012\r\n\r\nOne of these will work :)\r\n\r\n\r\n\r\n\r\n# 4. HOW TO\r\n\r\n## 4.1 Generate your own PLT\r\n\r\nThe problem with PLTs is that they are slow to generate and that they contain hard-coded links to .beam files on you system, so we cannot provide you with one.\r\n\r\nWe recommend you generate a \"tiny version\" of PLT. Otherwise you might end up waiting for search results forever (or run out of memory).\r\n\r\nIn order to generate a tiny PLT, run the following in your shell:\r\n       dialyzer --build_plt --apps kernel stdlib erts crypto sasl --output_plt tiny_plt\r\n\r\n## 4.2 Use your own PLT\r\n\r\nMake sure that application environment contains\r\n\r\n           {env, [{plt_path, PATH/TO/YOUR/PLT]}\r\nor\r\n           {env, [{plt_path, {priv_dir, PLT}}]}\r\n\r\n\r\n## 4.3 See some results on the command line\r\n\r\nIn PROJECT_ROOT:\r\n\r\n       bash> erl -pa apps/hint_search/ebin\r\n       > hint_search:start().\r\n       > hint_search:q(\"(erlang:timestamp(),erlang:timestamp())->integer()\").\r\n       {ok,[{{timer,now_diff,2},1.5},\r\n            {{dets,init,2},0.9},\r\n            {{crypto,dh_generate_parameters,2},0.9},\r\n            {{dets,next,2},0.9},\r\n       ...\r\n\r\n# 2. Technical details\r\n\r\nFrontend:\r\n- Cowboy web-server\r\n- Custom controllers\r\n- Regular web stuff\r\n- Fuzzy search on provided names\r\n\r\nBackend:\r\n- derive Module, Funciton, Arity from user request\r\n- create possible permutations of these\r\n- call Dialyzer to check types\r\n- create a ranking of Module-Function pairs based on Dialyzer output\r\n- return these to the user\r\n\r\nOn startup we read from a supplied PLT file and cache information on all available MFAs in the PLT (plt_cache_server)\r\n\r\nOnce we receive a request, we do the following:\r\n\r\n1. Derive Module, Funciton, Arity\r\n2. For each MFA in cache where A = Arity:\r\n    2.1 For each possible permutation of parameters in MFA  \r\n    2.2 Write custom functions:  \r\n\r\n            -spec func_permutation_1(UserProvidedSpecs...\r\n            func_permutation_1(Param1, Param2, Param3, ..., ParamArity) ->\r\n                       M:F(permutation 1 of Param1, Param2, Param3, ..., ParamArity).\r\n\r\n            -spec func_permutation_2(UserProvidedSpecs...\r\n            func_permutation_2(Param1, Param2, Param3, ..., ParamArity) ->\r\n                      M:F(permutation 2 of Param1, Param2, Param3, ..., ParamArity).\r\n            ...\r\n3. Once the file with custom functions is complete, run Dialyzer over it\r\n4. For each warning generated by Dialyzer:  \r\n      4.1 Match permutation and warning against MFA  \r\n      4.2 Store warnings with MFA  \r\n5. For each MFA for which there are no warnings (full type match):  \r\n      5.1 Store the MFA with no warnings\r\n6. For each MFA that we have  \r\n      6.1 Rank based on module name (extremely long and extremely short names decrease the rank)  \r\n      6.2 Rank based on function name (extremely long names decrease the rank)  \r\n      6.3 Rank based on warnings  \r\n      - Various diyalizer warnings decrease rank  \r\n      - If there are less warnings than permutations, it means that some of the permutations matched, increase rank  \r\n      - If there are no warnings, all permutations matched, increase rank  \r\n7. Final rank for each MFA is the sum all ranks for that MFA\r\n8. Reverse sort MFAs based on rank\r\n9. Return list of MFAs\r\n   \r\n# 3. Weak points and future solutions\r\n\r\n1. Requires PLT  \r\n    1.1 Takes insane amounts of time to build  \r\n    Solution: build several smaller PLTs, search across them  \r\n    1.2 Takes insane amounts of memory for Dialyzer to process   \r\n    Solution:  \r\n    - build several smaller PLTs, search across them cache  \r\n    - search result for common searches  \r\n\r\n2. Permutations  \r\n    2.1 Take a long time to generate on each search  \r\n    Solution:  \r\n    - precompute permutations when loading PLT on startup  \r\n    - save files with premutations for more common searches  \r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Hint","google":""}